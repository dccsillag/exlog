<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>logrun.internals API documentation</title>
<meta name="description" content="Internal mechanisms for experiment logging." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>logrun.internals</code></h1>
</header>
<section id="section-intro">
<p>Internal mechanisms for experiment logging.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Internal mechanisms for experiment logging.
&#34;&#34;&#34;

from typing import Optional, List, Set, Dict, Any
from abc import ABC, abstractmethod
import sys
import atexit
import warnings
import os
import subprocess
import tempfile
import platform
import inspect
import shutil
import tarfile
import time
import datetime
import uuid
import pickle

import xxhash
import psutil
import dill
import git


__all__ = [
    &#39;Artifact&#39;,
    &#39;get_script_path&#39;,
    &#39;ensure_dir_exists&#39;,
    &#39;eval_checksum&#39;,
    &#39;Experiment&#39;,
    &#39;experiment&#39;,
]


start_timestamp = time.time()
start_datetime = datetime.datetime.now()


def get_script_path() -&gt; str:
    &#34;&#34;&#34;
    Returns the path to the currently running script.
    &#34;&#34;&#34;

    path = os.path.abspath(sys.argv[0])
    assert os.path.exists(path)
    return path


def ensure_dir_exists(path: str) -&gt; str:
    &#34;&#34;&#34;
    Ensure that the the given path exists and is a directory. Returns the absolute path.
    &#34;&#34;&#34;

    path = os.path.abspath(os.path.realpath(path))

    if not os.path.exists(path):
        os.makedirs(path)

    return os.path.abspath(path)


def eval_checksum(path: str, state: Optional[xxhash.xxh3_64] = None, digest: bool = True) \
        -&gt; Optional[str]:
    &#34;&#34;&#34;
    Evaluates the checksum of a given path (which can be either a file or a directory).
    &#34;&#34;&#34;

    path = os.path.abspath(os.path.realpath(path))

    if state is None:
        state = xxhash.xxh3_64()

    if os.path.isfile(path):
        filesize = os.path.getsize(path)
        available_memory = psutil.virtual_memory().available
        if 10*filesize &lt;= available_memory:
            with open(path, &#39;rb&#39;) as file:
                state.update(file.read())
        else:
            chunksize = max(available_memory//10, state.block_size)
            with open(path, &#39;rb&#39;) as file:
                while True:
                    chunk = file.read(chunksize)
                    if not chunk:
                        break
                    state.update(chunk)
    elif os.path.isdir(path):
        for child in os.listdir(path):
            eval_checksum(os.path.join(path, child), state=state, digest=False)

    if digest:
        return state.hexdigest()


class Artifact(ABC):
    &#34;&#34;&#34;
    Represents that an object to be saved should be saved in a special way (instead of defaulting to
    using `dill`).
    &#34;&#34;&#34;

    @abstractmethod
    def write(self, path: str) -&gt; None:
        &#34;&#34;&#34;
        Write the object to the path `path`.
        &#34;&#34;&#34;

    @abstractmethod
    def read(self, path: str) -&gt; Any:
        &#34;&#34;&#34;
        Read the object from the path `path`.
        &#34;&#34;&#34;


# pylint: disable=too-few-public-methods
class Experiment:
    &#34;&#34;&#34;
    Represents an experiment to be logged.
    &#34;&#34;&#34;

    uuid: str
    &#34;&#34;&#34; The experiment&#39;s ID. &#34;&#34;&#34;
    no_save: bool
    &#34;&#34;&#34; If `True`, then don&#39;t save the experiment (nor setup stdout/stderr indirection). &#34;&#34;&#34;

    has_content: bool
    &#34;&#34;&#34; A member variable that tracks whether there is anything to log. &#34;&#34;&#34;
    output_files: Set[str]
    &#34;&#34;&#34; A list of files that the running script has produced as output. &#34;&#34;&#34;
    input_files: Set[str]
    &#34;&#34;&#34; A list of files that the running script has taken as input. &#34;&#34;&#34;
    extra_keys: Dict[str, Any]
    &#34;&#34;&#34; A dictionary containing extra information to store as part of the experiment. &#34;&#34;&#34;
    multiple: Dict[str, bool]
    &#34;&#34;&#34; A dictionary denoting, for each element of `extra_keys`, whether they represent a sequence
    of data (multiple data). &#34;&#34;&#34;

    def __init__(self):
        self.uuid = str(uuid.uuid4())
        self.no_save = hasattr(sys, &#39;ps1&#39;)  # True if in interactive shell

        self.has_content = False
        self.output_files = set()
        self.input_files = set()
        self.extra_keys = {}
        self.multiple = {}

        tmpstdout_handle, self.stdout_file = tempfile.mkstemp()  # &#39;stdout.out&#39;
        tmpstderr_handle, self.stderr_file = tempfile.mkstemp()  # &#39;stderr.out&#39;
        os.close(tmpstdout_handle)
        os.close(tmpstderr_handle)

        self._setup_stdout_redirection(self.stdout_file, self.stderr_file)

    def add_output_file(self, path: str) -&gt; None:
        &#34;&#34;&#34;
        Add an output file to be logged (a copy of the file is saved).
        &#34;&#34;&#34;

        self.has_content = True
        self.output_files.add(path)

    def add_input_file(self, path: str) -&gt; None:
        &#34;&#34;&#34;
        Add an input file to be logged (only its checksum is saved).
        &#34;&#34;&#34;

        self.has_content = True
        self.input_files.add(path)

    def add_extra_key(self, key: str, value: Any, overwrite: bool = True) -&gt; None:
        &#34;&#34;&#34;
        Add some arbitrary information to be saved with the experiment.

        If the key specified by `key` already exists, behaviour depends on the value of `overwrite`:
        if `overwrite` is `True`, then a warning is thrown and the value is overwritten; if
        `overwrite` is `False`, then both (or however many) values are kept in a list.
        &#34;&#34;&#34;

        self.has_content = True
        if key in self.extra_keys:
            if overwrite:
                warnings.warn(&#34;Overwriting key &#39;%s&#39; in experiment&#34; % key)
                self.extra_keys[key] = value
                self.multiple[key] = False
            else:
                if self.multiple[key]:
                    self.extra_keys[key].append(value)
                else:
                    self.multiple[key] = True
                    self.extra_keys[key] = [self.extra_keys[key], value]
        else:
            self.extra_keys[key] = value
            self.multiple[key] = False

    def _setup_stdout_redirection(self, stdout_file: str, stderr_file: str) -&gt; None:
        if not self.no_save:
            tee_stdout = subprocess.Popen([&#39;tee&#39;, stdout_file], stdin=subprocess.PIPE, start_new_session=True)
            os.dup2(tee_stdout.stdin.fileno(), sys.stdout.fileno())
            tee_stderr = subprocess.Popen([&#39;tee&#39;, stderr_file], stdin=subprocess.PIPE, start_new_session=True)
            os.dup2(tee_stderr.stdin.fileno(), sys.stderr.fileno())

    def _cleanup(self) -&gt; None:
        if os.path.exists(self.stdout_file):
            os.remove(self.stdout_file)
        if os.path.exists(self.stderr_file):
            os.remove(self.stderr_file)

    def save_experiment(self) -&gt; None:
        &#34;&#34;&#34;
        Save the experiment to the path given by the `$LOGRUN_ROOT` environment variable.
        &#34;&#34;&#34;

        from logrun import __version__

        if not self.has_content or self.no_save:
            self._cleanup()
            return

        rootpath = os.environ.get(&#39;LOGRUN_ROOT&#39;)
        if rootpath is None:
            raise OSError(&#34;Environment variable &#39;LOGRUN_ROOT&#39; is not defined! Cannot save experiment.&#34;)

        print(&#34;[Saving experiment: %s]&#34; % self.uuid)

        experiment_path = \
            ensure_dir_exists(os.path.join(rootpath, &#39;all_experiments&#39;, self.uuid))
        experiment_path_targz = experiment_path + &#39;.tar.gz&#39;
        experiment_by_outfile_path = \
            ensure_dir_exists(os.path.join(rootpath, &#39;experiments_by_output_file&#39;))
        experiment_by_infile_path = \
            ensure_dir_exists(os.path.join(rootpath, &#39;experiments_by_input_file&#39;))
        experiment_source_directory = ensure_dir_exists(os.path.join(experiment_path, &#39;source&#39;))

        for module in sys.modules.values():
            if not module.__name__.startswith(&#39;src.&#39;):
                continue

            try:
                source_file = inspect.getsourcefile(module)
                inspect.getsource(module)
            except (TypeError, OSError):
                # If we are here then this module doesn&#39;t have a corresponding source file
                # (or it&#39;s compiled).
                continue

            if os.path.getmtime(source_file) &gt; start_timestamp:
                print(&#34;Warning: source file [%s] modified since start of program execution!&#34;)

            with open(os.path.join(experiment_source_directory,
                                   os.path.relpath(source_file).replace(os.sep, &#39;%&#39;)), &#39;w&#39;) \
                    as file:
                file.write(inspect.getsource(module))
        source_file = sys.argv[0]
        if os.path.getmtime(source_file) &gt; start_timestamp:
            print(&#34;Warning: script file [%s] modified since start of execution!&#34;)
        with open(os.path.join(experiment_source_directory,
                               os.path.relpath(source_file).replace(os.sep, &#39;%&#39;)), &#39;w&#39;) as file:
            with open(source_file) as scriptfile:
                file.write(scriptfile.read())

        with open(os.path.join(experiment_path, &#39;meta.pickle&#39;), &#39;wb&#39;) as file:
            metadata = {
                &#39;host&#39;:                 platform.node(),
                &#39;user&#39;:                 os.getlogin(),
                &#39;cwd&#39;:                  os.getcwd(),
                &#39;argv&#39;:                 sys.argv,
                &#39;logrun_version&#39;:       __version__,
                &#39;start_execution_time&#39;: start_datetime,
                &#39;end_execution_time&#39;:   datetime.datetime.now(),
                &#39;environment&#39;:          dict(os.environ),
            }
            try:
                gitrepo = git.Repo(search_parent_directories=True)
                metadata[&#39;gitcommit&#39;] = gitrepo.head.object.hexsha
            except git.exc.InvalidGitRepositoryError:
                pass
            pickle.dump(metadata, file)

        shutil.copyfile(self.stdout_file, os.path.join(experiment_path, &#39;stdout.out&#39;))
        shutil.copyfile(self.stderr_file, os.path.join(experiment_path, &#39;stderr.out&#39;))

        output_files_path = ensure_dir_exists(os.path.join(experiment_path, &#39;output_files&#39;))
        for output_file in self.output_files:
            if not os.path.exists(output_file):
                print(&#34;Warning: output file does not exist: &#39;%s&#39;; skipping this one...&#34;
                      % output_file)
                continue

            output_file_repr = output_file.replace(os.sep, &#39;%&#39;)
            shutil.copyfile(output_file, os.path.join(output_files_path, output_file_repr))
            os.symlink(experiment_path_targz,
                       os.path.join(ensure_dir_exists(os.path.join(experiment_by_outfile_path,
                                                                   output_file_repr)),
                                    start_datetime.strftime(&#39;%Y-%m-%d-%H-%M-%S&#39;) + &#39;.&#39; + self.uuid))
        with open(os.path.join(experiment_path, &#39;input_files.pickle&#39;), &#39;wb&#39;) as file:
            pickle.dump({input_file: eval_checksum(input_file)
                         for input_file in self.input_files},
                        file)
        for input_file in self.input_files:
            input_file_repr = input_file.replace(os.sep, &#39;%&#39;)
            os.symlink(experiment_path_targz,
                       os.path.join(ensure_dir_exists(os.path.join(experiment_by_infile_path,
                                                                   input_file_repr)),
                                    start_datetime.strftime(&#39;%Y-%m-%d-%H-%M-%S&#39;) + &#39;.&#39; + self.uuid))

        extra_keys_path = ensure_dir_exists(os.path.join(experiment_path, &#39;extra_keys&#39;))

        for base_key, base_value in self.extra_keys.items():
            if self.multiple[base_key]:
                keyvals = {base_key + (f&#39;.%0{len(str(len(base_value)))}d&#39;) % k: base_value[k]
                           for k in range(len(base_value))}
            else:
                keyvals = {base_key: base_value}
            for key, value in keyvals.items():
                path = os.path.join(extra_keys_path, key)
                if isinstance(value, Artifact):
                    value.write(path)
                    with open(path + &#39;.read&#39;, &#39;wb&#39;) as file:
                        dill.dump(value.read, file)
                else:
                    with open(path, &#39;wb&#39;) as file:
                        dill.dump(value, file)

        with tarfile.open(experiment_path_targz, &#39;w:gz&#39;) as tar_handle:
            for root, _, files in os.walk(experiment_path):
                for file in files:
                    tar_handle.add(os.path.join(root, file))
        shutil.rmtree(experiment_path)

        self._cleanup()


experiment = Experiment()
atexit.register(experiment.save_experiment)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="logrun.internals.ensure_dir_exists"><code class="name flex">
<span>def <span class="ident">ensure_dir_exists</span></span>(<span>path: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Ensure that the the given path exists and is a directory. Returns the absolute path.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ensure_dir_exists(path: str) -&gt; str:
    &#34;&#34;&#34;
    Ensure that the the given path exists and is a directory. Returns the absolute path.
    &#34;&#34;&#34;

    path = os.path.abspath(os.path.realpath(path))

    if not os.path.exists(path):
        os.makedirs(path)

    return os.path.abspath(path)</code></pre>
</details>
</dd>
<dt id="logrun.internals.eval_checksum"><code class="name flex">
<span>def <span class="ident">eval_checksum</span></span>(<span>path: str, state: Optional[xxhash.xxh3_64] = None, digest: bool = True) ‑> Optional[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Evaluates the checksum of a given path (which can be either a file or a directory).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eval_checksum(path: str, state: Optional[xxhash.xxh3_64] = None, digest: bool = True) \
        -&gt; Optional[str]:
    &#34;&#34;&#34;
    Evaluates the checksum of a given path (which can be either a file or a directory).
    &#34;&#34;&#34;

    path = os.path.abspath(os.path.realpath(path))

    if state is None:
        state = xxhash.xxh3_64()

    if os.path.isfile(path):
        filesize = os.path.getsize(path)
        available_memory = psutil.virtual_memory().available
        if 10*filesize &lt;= available_memory:
            with open(path, &#39;rb&#39;) as file:
                state.update(file.read())
        else:
            chunksize = max(available_memory//10, state.block_size)
            with open(path, &#39;rb&#39;) as file:
                while True:
                    chunk = file.read(chunksize)
                    if not chunk:
                        break
                    state.update(chunk)
    elif os.path.isdir(path):
        for child in os.listdir(path):
            eval_checksum(os.path.join(path, child), state=state, digest=False)

    if digest:
        return state.hexdigest()</code></pre>
</details>
</dd>
<dt id="logrun.internals.get_script_path"><code class="name flex">
<span>def <span class="ident">get_script_path</span></span>(<span>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the path to the currently running script.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_script_path() -&gt; str:
    &#34;&#34;&#34;
    Returns the path to the currently running script.
    &#34;&#34;&#34;

    path = os.path.abspath(sys.argv[0])
    assert os.path.exists(path)
    return path</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="logrun.internals.Artifact"><code class="flex name class">
<span>class <span class="ident">Artifact</span></span>
</code></dt>
<dd>
<div class="desc"><p>Represents that an object to be saved should be saved in a special way (instead of defaulting to
using <code>dill</code>).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Artifact(ABC):
    &#34;&#34;&#34;
    Represents that an object to be saved should be saved in a special way (instead of defaulting to
    using `dill`).
    &#34;&#34;&#34;

    @abstractmethod
    def write(self, path: str) -&gt; None:
        &#34;&#34;&#34;
        Write the object to the path `path`.
        &#34;&#34;&#34;

    @abstractmethod
    def read(self, path: str) -&gt; Any:
        &#34;&#34;&#34;
        Read the object from the path `path`.
        &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="logrun.utils.data.NumpyArtifact" href="utils/data.html#logrun.utils.data.NumpyArtifact">NumpyArtifact</a></li>
<li><a title="logrun.utils.data.PandasArtifact" href="utils/data.html#logrun.utils.data.PandasArtifact">PandasArtifact</a></li>
<li><a title="logrun.utils.media.ImageArtifact" href="utils/media.html#logrun.utils.media.ImageArtifact">ImageArtifact</a></li>
<li><a title="logrun.utils.media.VideoArtifact" href="utils/media.html#logrun.utils.media.VideoArtifact">VideoArtifact</a></li>
<li><a title="logrun.utils.ml.PyTorchModel" href="utils/ml.html#logrun.utils.ml.PyTorchModel">PyTorchModel</a></li>
<li><a title="logrun.utils.ml.TensorFlowModel" href="utils/ml.html#logrun.utils.ml.TensorFlowModel">TensorFlowModel</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="logrun.internals.Artifact.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, path: str) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Read the object from the path <code>path</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def read(self, path: str) -&gt; Any:
    &#34;&#34;&#34;
    Read the object from the path `path`.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="logrun.internals.Artifact.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, path: str) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Write the object to the path <code>path</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def write(self, path: str) -&gt; None:
    &#34;&#34;&#34;
    Write the object to the path `path`.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="logrun.internals.Experiment"><code class="flex name class">
<span>class <span class="ident">Experiment</span></span>
</code></dt>
<dd>
<div class="desc"><p>Represents an experiment to be logged.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Experiment:
    &#34;&#34;&#34;
    Represents an experiment to be logged.
    &#34;&#34;&#34;

    uuid: str
    &#34;&#34;&#34; The experiment&#39;s ID. &#34;&#34;&#34;
    no_save: bool
    &#34;&#34;&#34; If `True`, then don&#39;t save the experiment (nor setup stdout/stderr indirection). &#34;&#34;&#34;

    has_content: bool
    &#34;&#34;&#34; A member variable that tracks whether there is anything to log. &#34;&#34;&#34;
    output_files: Set[str]
    &#34;&#34;&#34; A list of files that the running script has produced as output. &#34;&#34;&#34;
    input_files: Set[str]
    &#34;&#34;&#34; A list of files that the running script has taken as input. &#34;&#34;&#34;
    extra_keys: Dict[str, Any]
    &#34;&#34;&#34; A dictionary containing extra information to store as part of the experiment. &#34;&#34;&#34;
    multiple: Dict[str, bool]
    &#34;&#34;&#34; A dictionary denoting, for each element of `extra_keys`, whether they represent a sequence
    of data (multiple data). &#34;&#34;&#34;

    def __init__(self):
        self.uuid = str(uuid.uuid4())
        self.no_save = hasattr(sys, &#39;ps1&#39;)  # True if in interactive shell

        self.has_content = False
        self.output_files = set()
        self.input_files = set()
        self.extra_keys = {}
        self.multiple = {}

        tmpstdout_handle, self.stdout_file = tempfile.mkstemp()  # &#39;stdout.out&#39;
        tmpstderr_handle, self.stderr_file = tempfile.mkstemp()  # &#39;stderr.out&#39;
        os.close(tmpstdout_handle)
        os.close(tmpstderr_handle)

        self._setup_stdout_redirection(self.stdout_file, self.stderr_file)

    def add_output_file(self, path: str) -&gt; None:
        &#34;&#34;&#34;
        Add an output file to be logged (a copy of the file is saved).
        &#34;&#34;&#34;

        self.has_content = True
        self.output_files.add(path)

    def add_input_file(self, path: str) -&gt; None:
        &#34;&#34;&#34;
        Add an input file to be logged (only its checksum is saved).
        &#34;&#34;&#34;

        self.has_content = True
        self.input_files.add(path)

    def add_extra_key(self, key: str, value: Any, overwrite: bool = True) -&gt; None:
        &#34;&#34;&#34;
        Add some arbitrary information to be saved with the experiment.

        If the key specified by `key` already exists, behaviour depends on the value of `overwrite`:
        if `overwrite` is `True`, then a warning is thrown and the value is overwritten; if
        `overwrite` is `False`, then both (or however many) values are kept in a list.
        &#34;&#34;&#34;

        self.has_content = True
        if key in self.extra_keys:
            if overwrite:
                warnings.warn(&#34;Overwriting key &#39;%s&#39; in experiment&#34; % key)
                self.extra_keys[key] = value
                self.multiple[key] = False
            else:
                if self.multiple[key]:
                    self.extra_keys[key].append(value)
                else:
                    self.multiple[key] = True
                    self.extra_keys[key] = [self.extra_keys[key], value]
        else:
            self.extra_keys[key] = value
            self.multiple[key] = False

    def _setup_stdout_redirection(self, stdout_file: str, stderr_file: str) -&gt; None:
        if not self.no_save:
            tee_stdout = subprocess.Popen([&#39;tee&#39;, stdout_file], stdin=subprocess.PIPE, start_new_session=True)
            os.dup2(tee_stdout.stdin.fileno(), sys.stdout.fileno())
            tee_stderr = subprocess.Popen([&#39;tee&#39;, stderr_file], stdin=subprocess.PIPE, start_new_session=True)
            os.dup2(tee_stderr.stdin.fileno(), sys.stderr.fileno())

    def _cleanup(self) -&gt; None:
        if os.path.exists(self.stdout_file):
            os.remove(self.stdout_file)
        if os.path.exists(self.stderr_file):
            os.remove(self.stderr_file)

    def save_experiment(self) -&gt; None:
        &#34;&#34;&#34;
        Save the experiment to the path given by the `$LOGRUN_ROOT` environment variable.
        &#34;&#34;&#34;

        from logrun import __version__

        if not self.has_content or self.no_save:
            self._cleanup()
            return

        rootpath = os.environ.get(&#39;LOGRUN_ROOT&#39;)
        if rootpath is None:
            raise OSError(&#34;Environment variable &#39;LOGRUN_ROOT&#39; is not defined! Cannot save experiment.&#34;)

        print(&#34;[Saving experiment: %s]&#34; % self.uuid)

        experiment_path = \
            ensure_dir_exists(os.path.join(rootpath, &#39;all_experiments&#39;, self.uuid))
        experiment_path_targz = experiment_path + &#39;.tar.gz&#39;
        experiment_by_outfile_path = \
            ensure_dir_exists(os.path.join(rootpath, &#39;experiments_by_output_file&#39;))
        experiment_by_infile_path = \
            ensure_dir_exists(os.path.join(rootpath, &#39;experiments_by_input_file&#39;))
        experiment_source_directory = ensure_dir_exists(os.path.join(experiment_path, &#39;source&#39;))

        for module in sys.modules.values():
            if not module.__name__.startswith(&#39;src.&#39;):
                continue

            try:
                source_file = inspect.getsourcefile(module)
                inspect.getsource(module)
            except (TypeError, OSError):
                # If we are here then this module doesn&#39;t have a corresponding source file
                # (or it&#39;s compiled).
                continue

            if os.path.getmtime(source_file) &gt; start_timestamp:
                print(&#34;Warning: source file [%s] modified since start of program execution!&#34;)

            with open(os.path.join(experiment_source_directory,
                                   os.path.relpath(source_file).replace(os.sep, &#39;%&#39;)), &#39;w&#39;) \
                    as file:
                file.write(inspect.getsource(module))
        source_file = sys.argv[0]
        if os.path.getmtime(source_file) &gt; start_timestamp:
            print(&#34;Warning: script file [%s] modified since start of execution!&#34;)
        with open(os.path.join(experiment_source_directory,
                               os.path.relpath(source_file).replace(os.sep, &#39;%&#39;)), &#39;w&#39;) as file:
            with open(source_file) as scriptfile:
                file.write(scriptfile.read())

        with open(os.path.join(experiment_path, &#39;meta.pickle&#39;), &#39;wb&#39;) as file:
            metadata = {
                &#39;host&#39;:                 platform.node(),
                &#39;user&#39;:                 os.getlogin(),
                &#39;cwd&#39;:                  os.getcwd(),
                &#39;argv&#39;:                 sys.argv,
                &#39;logrun_version&#39;:       __version__,
                &#39;start_execution_time&#39;: start_datetime,
                &#39;end_execution_time&#39;:   datetime.datetime.now(),
                &#39;environment&#39;:          dict(os.environ),
            }
            try:
                gitrepo = git.Repo(search_parent_directories=True)
                metadata[&#39;gitcommit&#39;] = gitrepo.head.object.hexsha
            except git.exc.InvalidGitRepositoryError:
                pass
            pickle.dump(metadata, file)

        shutil.copyfile(self.stdout_file, os.path.join(experiment_path, &#39;stdout.out&#39;))
        shutil.copyfile(self.stderr_file, os.path.join(experiment_path, &#39;stderr.out&#39;))

        output_files_path = ensure_dir_exists(os.path.join(experiment_path, &#39;output_files&#39;))
        for output_file in self.output_files:
            if not os.path.exists(output_file):
                print(&#34;Warning: output file does not exist: &#39;%s&#39;; skipping this one...&#34;
                      % output_file)
                continue

            output_file_repr = output_file.replace(os.sep, &#39;%&#39;)
            shutil.copyfile(output_file, os.path.join(output_files_path, output_file_repr))
            os.symlink(experiment_path_targz,
                       os.path.join(ensure_dir_exists(os.path.join(experiment_by_outfile_path,
                                                                   output_file_repr)),
                                    start_datetime.strftime(&#39;%Y-%m-%d-%H-%M-%S&#39;) + &#39;.&#39; + self.uuid))
        with open(os.path.join(experiment_path, &#39;input_files.pickle&#39;), &#39;wb&#39;) as file:
            pickle.dump({input_file: eval_checksum(input_file)
                         for input_file in self.input_files},
                        file)
        for input_file in self.input_files:
            input_file_repr = input_file.replace(os.sep, &#39;%&#39;)
            os.symlink(experiment_path_targz,
                       os.path.join(ensure_dir_exists(os.path.join(experiment_by_infile_path,
                                                                   input_file_repr)),
                                    start_datetime.strftime(&#39;%Y-%m-%d-%H-%M-%S&#39;) + &#39;.&#39; + self.uuid))

        extra_keys_path = ensure_dir_exists(os.path.join(experiment_path, &#39;extra_keys&#39;))

        for base_key, base_value in self.extra_keys.items():
            if self.multiple[base_key]:
                keyvals = {base_key + (f&#39;.%0{len(str(len(base_value)))}d&#39;) % k: base_value[k]
                           for k in range(len(base_value))}
            else:
                keyvals = {base_key: base_value}
            for key, value in keyvals.items():
                path = os.path.join(extra_keys_path, key)
                if isinstance(value, Artifact):
                    value.write(path)
                    with open(path + &#39;.read&#39;, &#39;wb&#39;) as file:
                        dill.dump(value.read, file)
                else:
                    with open(path, &#39;wb&#39;) as file:
                        dill.dump(value, file)

        with tarfile.open(experiment_path_targz, &#39;w:gz&#39;) as tar_handle:
            for root, _, files in os.walk(experiment_path):
                for file in files:
                    tar_handle.add(os.path.join(root, file))
        shutil.rmtree(experiment_path)

        self._cleanup()</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="logrun.internals.Experiment.extra_keys"><code class="name">var <span class="ident">extra_keys</span> : Dict[str, Any]</code></dt>
<dd>
<div class="desc"><p>A dictionary containing extra information to store as part of the experiment.</p></div>
</dd>
<dt id="logrun.internals.Experiment.has_content"><code class="name">var <span class="ident">has_content</span> : bool</code></dt>
<dd>
<div class="desc"><p>A member variable that tracks whether there is anything to log.</p></div>
</dd>
<dt id="logrun.internals.Experiment.input_files"><code class="name">var <span class="ident">input_files</span> : Set[str]</code></dt>
<dd>
<div class="desc"><p>A list of files that the running script has taken as input.</p></div>
</dd>
<dt id="logrun.internals.Experiment.multiple"><code class="name">var <span class="ident">multiple</span> : Dict[str, bool]</code></dt>
<dd>
<div class="desc"><p>A dictionary denoting, for each element of <code>extra_keys</code>, whether they represent a sequence
of data (multiple data).</p></div>
</dd>
<dt id="logrun.internals.Experiment.no_save"><code class="name">var <span class="ident">no_save</span> : bool</code></dt>
<dd>
<div class="desc"><p>If <code>True</code>, then don't save the experiment (nor setup stdout/stderr indirection).</p></div>
</dd>
<dt id="logrun.internals.Experiment.output_files"><code class="name">var <span class="ident">output_files</span> : Set[str]</code></dt>
<dd>
<div class="desc"><p>A list of files that the running script has produced as output.</p></div>
</dd>
<dt id="logrun.internals.Experiment.uuid"><code class="name">var <span class="ident">uuid</span> : str</code></dt>
<dd>
<div class="desc"><p>The experiment's ID.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="logrun.internals.Experiment.add_extra_key"><code class="name flex">
<span>def <span class="ident">add_extra_key</span></span>(<span>self, key: str, value: Any, overwrite: bool = True) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add some arbitrary information to be saved with the experiment.</p>
<p>If the key specified by <code>key</code> already exists, behaviour depends on the value of <code>overwrite</code>:
if <code>overwrite</code> is <code>True</code>, then a warning is thrown and the value is overwritten; if
<code>overwrite</code> is <code>False</code>, then both (or however many) values are kept in a list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_extra_key(self, key: str, value: Any, overwrite: bool = True) -&gt; None:
    &#34;&#34;&#34;
    Add some arbitrary information to be saved with the experiment.

    If the key specified by `key` already exists, behaviour depends on the value of `overwrite`:
    if `overwrite` is `True`, then a warning is thrown and the value is overwritten; if
    `overwrite` is `False`, then both (or however many) values are kept in a list.
    &#34;&#34;&#34;

    self.has_content = True
    if key in self.extra_keys:
        if overwrite:
            warnings.warn(&#34;Overwriting key &#39;%s&#39; in experiment&#34; % key)
            self.extra_keys[key] = value
            self.multiple[key] = False
        else:
            if self.multiple[key]:
                self.extra_keys[key].append(value)
            else:
                self.multiple[key] = True
                self.extra_keys[key] = [self.extra_keys[key], value]
    else:
        self.extra_keys[key] = value
        self.multiple[key] = False</code></pre>
</details>
</dd>
<dt id="logrun.internals.Experiment.add_input_file"><code class="name flex">
<span>def <span class="ident">add_input_file</span></span>(<span>self, path: str) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add an input file to be logged (only its checksum is saved).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_input_file(self, path: str) -&gt; None:
    &#34;&#34;&#34;
    Add an input file to be logged (only its checksum is saved).
    &#34;&#34;&#34;

    self.has_content = True
    self.input_files.add(path)</code></pre>
</details>
</dd>
<dt id="logrun.internals.Experiment.add_output_file"><code class="name flex">
<span>def <span class="ident">add_output_file</span></span>(<span>self, path: str) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add an output file to be logged (a copy of the file is saved).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_output_file(self, path: str) -&gt; None:
    &#34;&#34;&#34;
    Add an output file to be logged (a copy of the file is saved).
    &#34;&#34;&#34;

    self.has_content = True
    self.output_files.add(path)</code></pre>
</details>
</dd>
<dt id="logrun.internals.Experiment.save_experiment"><code class="name flex">
<span>def <span class="ident">save_experiment</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Save the experiment to the path given by the <code>$LOGRUN_ROOT</code> environment variable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_experiment(self) -&gt; None:
    &#34;&#34;&#34;
    Save the experiment to the path given by the `$LOGRUN_ROOT` environment variable.
    &#34;&#34;&#34;

    from logrun import __version__

    if not self.has_content or self.no_save:
        self._cleanup()
        return

    rootpath = os.environ.get(&#39;LOGRUN_ROOT&#39;)
    if rootpath is None:
        raise OSError(&#34;Environment variable &#39;LOGRUN_ROOT&#39; is not defined! Cannot save experiment.&#34;)

    print(&#34;[Saving experiment: %s]&#34; % self.uuid)

    experiment_path = \
        ensure_dir_exists(os.path.join(rootpath, &#39;all_experiments&#39;, self.uuid))
    experiment_path_targz = experiment_path + &#39;.tar.gz&#39;
    experiment_by_outfile_path = \
        ensure_dir_exists(os.path.join(rootpath, &#39;experiments_by_output_file&#39;))
    experiment_by_infile_path = \
        ensure_dir_exists(os.path.join(rootpath, &#39;experiments_by_input_file&#39;))
    experiment_source_directory = ensure_dir_exists(os.path.join(experiment_path, &#39;source&#39;))

    for module in sys.modules.values():
        if not module.__name__.startswith(&#39;src.&#39;):
            continue

        try:
            source_file = inspect.getsourcefile(module)
            inspect.getsource(module)
        except (TypeError, OSError):
            # If we are here then this module doesn&#39;t have a corresponding source file
            # (or it&#39;s compiled).
            continue

        if os.path.getmtime(source_file) &gt; start_timestamp:
            print(&#34;Warning: source file [%s] modified since start of program execution!&#34;)

        with open(os.path.join(experiment_source_directory,
                               os.path.relpath(source_file).replace(os.sep, &#39;%&#39;)), &#39;w&#39;) \
                as file:
            file.write(inspect.getsource(module))
    source_file = sys.argv[0]
    if os.path.getmtime(source_file) &gt; start_timestamp:
        print(&#34;Warning: script file [%s] modified since start of execution!&#34;)
    with open(os.path.join(experiment_source_directory,
                           os.path.relpath(source_file).replace(os.sep, &#39;%&#39;)), &#39;w&#39;) as file:
        with open(source_file) as scriptfile:
            file.write(scriptfile.read())

    with open(os.path.join(experiment_path, &#39;meta.pickle&#39;), &#39;wb&#39;) as file:
        metadata = {
            &#39;host&#39;:                 platform.node(),
            &#39;user&#39;:                 os.getlogin(),
            &#39;cwd&#39;:                  os.getcwd(),
            &#39;argv&#39;:                 sys.argv,
            &#39;logrun_version&#39;:       __version__,
            &#39;start_execution_time&#39;: start_datetime,
            &#39;end_execution_time&#39;:   datetime.datetime.now(),
            &#39;environment&#39;:          dict(os.environ),
        }
        try:
            gitrepo = git.Repo(search_parent_directories=True)
            metadata[&#39;gitcommit&#39;] = gitrepo.head.object.hexsha
        except git.exc.InvalidGitRepositoryError:
            pass
        pickle.dump(metadata, file)

    shutil.copyfile(self.stdout_file, os.path.join(experiment_path, &#39;stdout.out&#39;))
    shutil.copyfile(self.stderr_file, os.path.join(experiment_path, &#39;stderr.out&#39;))

    output_files_path = ensure_dir_exists(os.path.join(experiment_path, &#39;output_files&#39;))
    for output_file in self.output_files:
        if not os.path.exists(output_file):
            print(&#34;Warning: output file does not exist: &#39;%s&#39;; skipping this one...&#34;
                  % output_file)
            continue

        output_file_repr = output_file.replace(os.sep, &#39;%&#39;)
        shutil.copyfile(output_file, os.path.join(output_files_path, output_file_repr))
        os.symlink(experiment_path_targz,
                   os.path.join(ensure_dir_exists(os.path.join(experiment_by_outfile_path,
                                                               output_file_repr)),
                                start_datetime.strftime(&#39;%Y-%m-%d-%H-%M-%S&#39;) + &#39;.&#39; + self.uuid))
    with open(os.path.join(experiment_path, &#39;input_files.pickle&#39;), &#39;wb&#39;) as file:
        pickle.dump({input_file: eval_checksum(input_file)
                     for input_file in self.input_files},
                    file)
    for input_file in self.input_files:
        input_file_repr = input_file.replace(os.sep, &#39;%&#39;)
        os.symlink(experiment_path_targz,
                   os.path.join(ensure_dir_exists(os.path.join(experiment_by_infile_path,
                                                               input_file_repr)),
                                start_datetime.strftime(&#39;%Y-%m-%d-%H-%M-%S&#39;) + &#39;.&#39; + self.uuid))

    extra_keys_path = ensure_dir_exists(os.path.join(experiment_path, &#39;extra_keys&#39;))

    for base_key, base_value in self.extra_keys.items():
        if self.multiple[base_key]:
            keyvals = {base_key + (f&#39;.%0{len(str(len(base_value)))}d&#39;) % k: base_value[k]
                       for k in range(len(base_value))}
        else:
            keyvals = {base_key: base_value}
        for key, value in keyvals.items():
            path = os.path.join(extra_keys_path, key)
            if isinstance(value, Artifact):
                value.write(path)
                with open(path + &#39;.read&#39;, &#39;wb&#39;) as file:
                    dill.dump(value.read, file)
            else:
                with open(path, &#39;wb&#39;) as file:
                    dill.dump(value, file)

    with tarfile.open(experiment_path_targz, &#39;w:gz&#39;) as tar_handle:
        for root, _, files in os.walk(experiment_path):
            for file in files:
                tar_handle.add(os.path.join(root, file))
    shutil.rmtree(experiment_path)

    self._cleanup()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="logrun" href="index.html">logrun</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="logrun.internals.ensure_dir_exists" href="#logrun.internals.ensure_dir_exists">ensure_dir_exists</a></code></li>
<li><code><a title="logrun.internals.eval_checksum" href="#logrun.internals.eval_checksum">eval_checksum</a></code></li>
<li><code><a title="logrun.internals.get_script_path" href="#logrun.internals.get_script_path">get_script_path</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="logrun.internals.Artifact" href="#logrun.internals.Artifact">Artifact</a></code></h4>
<ul class="">
<li><code><a title="logrun.internals.Artifact.read" href="#logrun.internals.Artifact.read">read</a></code></li>
<li><code><a title="logrun.internals.Artifact.write" href="#logrun.internals.Artifact.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="logrun.internals.Experiment" href="#logrun.internals.Experiment">Experiment</a></code></h4>
<ul class="two-column">
<li><code><a title="logrun.internals.Experiment.add_extra_key" href="#logrun.internals.Experiment.add_extra_key">add_extra_key</a></code></li>
<li><code><a title="logrun.internals.Experiment.add_input_file" href="#logrun.internals.Experiment.add_input_file">add_input_file</a></code></li>
<li><code><a title="logrun.internals.Experiment.add_output_file" href="#logrun.internals.Experiment.add_output_file">add_output_file</a></code></li>
<li><code><a title="logrun.internals.Experiment.extra_keys" href="#logrun.internals.Experiment.extra_keys">extra_keys</a></code></li>
<li><code><a title="logrun.internals.Experiment.has_content" href="#logrun.internals.Experiment.has_content">has_content</a></code></li>
<li><code><a title="logrun.internals.Experiment.input_files" href="#logrun.internals.Experiment.input_files">input_files</a></code></li>
<li><code><a title="logrun.internals.Experiment.multiple" href="#logrun.internals.Experiment.multiple">multiple</a></code></li>
<li><code><a title="logrun.internals.Experiment.no_save" href="#logrun.internals.Experiment.no_save">no_save</a></code></li>
<li><code><a title="logrun.internals.Experiment.output_files" href="#logrun.internals.Experiment.output_files">output_files</a></code></li>
<li><code><a title="logrun.internals.Experiment.save_experiment" href="#logrun.internals.Experiment.save_experiment">save_experiment</a></code></li>
<li><code><a title="logrun.internals.Experiment.uuid" href="#logrun.internals.Experiment.uuid">uuid</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>